"""Register Microservice (modular)\n--------------------------------\nPuerto interno: 8001\nBase de datos: PostgreSQL (studentdb)\nFunciones CRUD de estudiantes y p√°gina Bootstrap.\n"""\n\nfrom pathlib import Path\nfrom typing import List\nimport os\nimport asyncpg\nfrom fastapi import FastAPI, HTTPException, Request, status\nfrom fastapi.responses import HTMLResponse\nfrom fastapi.templating import Jinja2Templates\nfrom pydantic import BaseModel\n\n# ---------------------------------------------------------------------------\nPORT = 8001\nDB_USER = os.getenv("POSTGRES_USER", "postgrest1")\nDB_PASSWORD = os.getenv("POSTGRES_PASSWORD", "Sebasalejandro22")\nDB_NAME = os.getenv("POSTGRES_DB", "studentdb")\nDB_HOST = os.getenv("POSTGRES_HOST", "postgres-db")\nDB_PORT = os.getenv("POSTGRES_PORT", "5432")\nDATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"\n\nBASE_DIR = Path(__file__).resolve().parent\ntemplates = Jinja2Templates(directory=str(BASE_DIR / "templates"))\n\napp = FastAPI(title="Register Service", version="1.0.0")\n\n\nclass StudentIn(BaseModel):\n    full_name: str\n    email: str\n\n\nclass StudentOut(StudentIn):\n    id: int\n\n\n@app.on_event("startup")\nasync def startup_event():\n    app.state.pool = await asyncpg.create_pool(DATABASE_URL, min_size=1, max_size=5)\n    async with app.state.pool.acquire() as conn:\n        await conn.execute(\n            """CREATE TABLE IF NOT EXISTS students (\n                id SERIAL PRIMARY KEY,\n                full_name TEXT NOT NULL,\n                email TEXT UNIQUE NOT NULL\n            );"""\n        )\n\n\n@app.on_event("shutdown")\nasync def shutdown_event():\n    await app.state.pool.close()\n\n\n@app.get("/", response_class=HTMLResponse)\nasync def root(request: Request):\n    return templates.TemplateResponse("index.html", {"request": request, "service": "register-service"})\n\n\n@app.post("/students", response_model=StudentOut, status_code=status.HTTP_201_CREATED)\nasync def create_student(student: StudentIn):\n    query = "INSERT INTO students(full_name, email) VALUES ($1,$2) RETURNING id;"\n    async with app.state.pool.acquire() as conn:\n        try:\n            new_id = await conn.fetchval(query, student.full_name, student.email)\n        except asyncpg.UniqueViolationError:\n            raise HTTPException(status_code=400, detail="Email already exists")\n    return StudentOut(id=new_id, **student.dict())\n\n\n@app.get("/students", response_model=List[StudentOut])\nasync def list_students(limit: int = 100):\n    query = "SELECT id, full_name, email FROM students ORDER BY id LIMIT $1;"\n    async with app.state.pool.acquire() as conn:\n        rows = await conn.fetch(query, limit)\n    return [StudentOut(id=r["id"], full_name=r["full_name"], email=r["email"]) for r in rows]\n\n\n@app.get("/students/{student_id}", response_model=StudentOut)\nasync def get_student(student_id: int):\n    query = "SELECT id, full_name, email FROM students WHERE id=$1;"\n    async with app.state.pool.acquire() as conn:\n        row = await conn.fetchrow(query, student_id)\n    if not row:\n        raise HTTPException(status_code=404, detail="Student not found")\n    return StudentOut(id=row["id"], full_name=row["full_name"], email=row["email"])\n\n\nif __name__ == "__main__":\n    import uvicorn\n\n    uvicorn.run("main:app", host="0.0.0.0", port=PORT, reload=True)
